<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" integrity="sha384-BTL0nVi8DnMrNdMQZG1Ww6yasK9ZGnUxL1ZWukXQ7fygA1py52yPp9W4wrR00VML" crossorigin="anonymous">
        <style>
/*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/ body { font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback"; font-size: 14px; padding: 0 26px; line-height: 22px; word-wrap: break-word; } #code-csp-warning { position: fixed; top: 0; right: 0; color: white; margin: 16px; text-align: center; font-size: 12px; font-family: sans-serif; background-color:#444444; cursor: pointer; padding: 6px; box-shadow: 1px 1px 1px rgba(0,0,0,.25); } #code-csp-warning:hover { text-decoration: none; background-color:#007acc; box-shadow: 2px 2px 2px rgba(0,0,0,.25); } body.scrollBeyondLastLine { margin-bottom: calc(100vh - 22px); } body.showEditorSelection .code-line { position: relative; } body.showEditorSelection .code-active-line:before, body.showEditorSelection .code-line:hover:before { content: ""; display: block; position: absolute; top: 0; left: -12px; height: 100%; } body.showEditorSelection li.code-active-line:before, body.showEditorSelection li.code-line:hover:before { left: -30px; } .vscode-light.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(0, 0, 0, 0.15); } .vscode-light.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(0, 0, 0, 0.40); } .vscode-light.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-dark.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 255, 255, 0.4); } .vscode-dark.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 255, 255, 0.60); } .vscode-dark.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-high-contrast.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 160, 0, 0.7); } .vscode-high-contrast.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 160, 0, 1); } .vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before { border-left: none; } img { max-width: 100%; max-height: 100%; } a { text-decoration: none; } a:hover { text-decoration: underline; } a:focus, input:focus, select:focus, textarea:focus { outline: 1px solid -webkit-focus-ring-color; outline-offset: -1px; } hr { border: 0; height: 2px; border-bottom: 2px solid; } h1 { padding-bottom: 0.3em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; } h1, h2, h3 { font-weight: normal; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; line-height: auto; } table { border-collapse: collapse; } table > thead > tr > th { text-align: left; border-bottom: 1px solid; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td { padding: 5px 10px; } table > tbody > tr + tr > td { border-top: 1px solid; } blockquote { margin: 0 7px 0 5px; padding: 0 16px 0 10px; border-left-width: 5px; border-left-style: solid; } code { font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback"; font-size: 14px; line-height: 19px; } body.wordWrap pre { white-space: pre-wrap; } .mac code { font-size: 12px; line-height: 18px; } pre:not(.hljs), pre.hljs code > div { padding: 16px; border-radius: 3px; overflow: auto; } /** Theming */ pre code { color: var(--vscode-editor-foreground); } .vscode-light pre:not(.hljs), .vscode-light code > div { background-color: rgba(220, 220, 220, 0.4); } .vscode-dark pre:not(.hljs), .vscode-dark code > div { background-color: rgba(10, 10, 10, 0.4); } .vscode-high-contrast pre:not(.hljs), .vscode-high-contrast code > div { background-color: rgb(0, 0, 0); } .vscode-high-contrast h1 { border-color: rgb(0, 0, 0); } .vscode-light table > thead > tr > th { border-color: rgba(0, 0, 0, 0.69); } .vscode-dark table > thead > tr > th { border-color: rgba(255, 255, 255, 0.69); } .vscode-light h1, .vscode-light hr, .vscode-light table > tbody > tr + tr > td { border-color: rgba(0, 0, 0, 0.18); } .vscode-dark h1, .vscode-dark hr, .vscode-dark table > tbody > tr + tr > td { border-color: rgba(255, 255, 255, 0.18); } 
</style>
<style>
/* Tomorrow Theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
</style>
<style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <h2 id="transport-layer">Transport Layer</h2>
<h3 id="transport-layer-services">Transport Layer Services</h3>
<ul>
<li>logical communication between app processes running on different hosts</li>
<li>run on end systems, protocols:
<ul>
<li>send side: break app messages into segments, pass to network layer</li>
<li>receiver side: reassembles segment into messages, passes to app layer</li>
</ul>
</li>
<li>2 protocols: UDP and TCP</li>
</ul>
<p>Transport vs Network Layer</p>
<ul>
<li>Network Layer: logical communication between hosts (the next layer)</li>
<li>Transport Layer: logical communication between processes
<ul>
<li>depends on and enhances network layer services</li>
</ul>
</li>
</ul>
<p>TCP: in-order, reliable delivery</p>
<ul>
<li>congestion, flow and connection control</li>
</ul>
<p>UDP: unreliable, unordered, &quot;best-effort&quot;</p>
<p>Neither has delay guarantees or bandwidth guarantees</p>
<h3 id="multiplexingde-multiplexing">Multiplexing/De-Multiplexing</h3>
<ul>
<li>multiplexing at sender: handle data from multiple sockets, add transport header</li>
<li>de-multiplexing at receiver: use header info to deliver segment to proper socket
<ul>
<li>host receives a datagram
<ul>
<li>has 32 bits (source port, dest port)</li>
<li>has source/dest IP address</li>
<li>&quot;transport layer segment&quot;</li>
</ul>
</li>
<li>host use IP addresses and port numbers for correct socket for app layer</li>
</ul>
</li>
</ul>
<p>Connection-less De-Multiplexing (UDP)</p>
<ul>
<li>only cares about dest port + IP</li>
<li>socket has host-local port #</li>
<li>when host receives UDP segment, check port # and direct
<ul>
<li>same dest + port # but different source will be directed to same socket</li>
</ul>
</li>
</ul>
<p>Connection based Demux (TCP) - Transmission Control Protocol</p>
<ul>
<li>4 tuples (source/dest ip/port)</li>
<li>use all 4 values</li>
<li>web servers have different sockets for each connecting client
<ul>
<li>non-persistent will have different socket for each request</li>
<li>the server can be threaded</li>
</ul>
</li>
</ul>
<h3 id="connection-less-transport-udp">Connection-less Transport (UDP)</h3>
<ul>
<li>UDP -&gt; User Datagram Protocol (RFC 768)</li>
<li>connection-less = no handshaking, each segment independently handled (no state)</li>
<li>streaming, DNS, SNMP</li>
<li>add reliability at application layer</li>
</ul>
<p>Segment Header</p>
<ul>
<li>port numbers, length (length including header, in bytes), checksum and then payload</li>
<li>benefits of UDP
<ul>
<li>small header size</li>
<li>no congestion control - fast</li>
<li>fast in general</li>
</ul>
</li>
</ul>
<p>Checksum</p>
<ul>
<li>goal: detect errors (flipped bits) in transmitted segments</li>
<li>sender: treat contents and header as sequence of 16 bit numbers
<ul>
<li>checksum made by adding everything</li>
</ul>
</li>
<li>receiver:
<ul>
<li>compute checksum of segment, check if they equal</li>
</ul>
</li>
<li>use 1's compliment to break it up (flip at first 0, or just add a 1 at the end + flip after)</li>
</ul>
<h3 id="principles-of-reliable-data-transport">Principles of Reliable Data Transport</h3>
<ul>
<li>RDT -&gt; reliable data transfer</li>
<li>based off of UDT first</li>
<li>rdt_send -&gt; udt_send -&gt; rdt_rcv -&gt; deliver_data</li>
<li>use FSM to illustrate, build it up. consider only unidirectional</li>
</ul>
<p>rdt1.0</p>
<ul>
<li>assuming underlying udt is perfectly reliable
<ul>
<li>no bit error and no loss of packet</li>
</ul>
</li>
<li>FSM of the 4 steps (packing and unpacking) should be good
<img src="file:///Users/davidliu/Documents/Year%204/Notes/Networks/images/3.png" alt="image"></li>
</ul>
<p>rdt2.0</p>
<ul>
<li>underlying channel may flip bits</li>
<li>use checksum to detect errors</li>
<li>how to recover from errors?</li>
<li>ACK - tell sender the packet was good</li>
<li>NAK -&gt; say it has errors
<ul>
<li>sender will resend</li>
</ul>
</li>
<li>new: error detection + feedback control</li>
<li>problem: what if ACK/NAK is corrupted?
<ul>
<li>cant retransmit: duplicate, need to add sequence number to each pkt</li>
<li>stop and wait (sender)</li>
</ul>
</li>
</ul>
<p>rdt2.1</p>
<ul>
<li>sequence number added to pkt (only 1 and 0 needed)</li>
<li>check if ACK or NAK is corrupted
<ul>
<li>2x state now, check if seq has 0 or 1</li>
</ul>
</li>
<li>must check if received packet is duplicate
<ul>
<li>receiver does not know if the last ACK/NAK is received properly at sender.</li>
</ul>
</li>
</ul>
<p>rdt2.2: NAK-free</p>
<ul>
<li>no more NAK, include seq # of pkt being ACKed
<ul>
<li>sends for last pkr received OK</li>
</ul>
</li>
<li>duplicate ACK at sender means NAK
<ul>
<li>retransmit current one</li>
</ul>
</li>
</ul>
<p>rdt3.0: channels with errors and loss</p>
<ul>
<li>
<p>if underlying channel can also lose packets</p>
</li>
<li>
<p>sender wait a reasonable amount of time for ACK</p>
<ul>
<li>retransmit if no ACK received (assume loss)</li>
</ul>
</li>
<li>
<p>requires a countdown timer</p>
</li>
<li>
<p>even when duplicate, still send an ACK with segment number</p>
</li>
<li>
<p>performance is bad, because you have to wait</p>
<ul>
<li>network protocol limiting use of physical resources</li>
</ul>
</li>
<li>
<p>Utilization: fraction of time sender busy sending</p>
<ul>
<li><code>L/R / (RTT + L/R)</code> -&gt; no pipelining</li>
</ul>
</li>
</ul>
<p>Stop and wait operation</p>
<ul>
<li>RTT is needed to see if a package has successfully been received.
<ul>
<li>RTT + L/R</li>
</ul>
</li>
</ul>
<p>Pipelined Protocols</p>
<ul>
<li>pipelining: allow multiple &quot;in-flight&quot;, yet to-be-ack pkts
<ul>
<li>range of sequence number needs to be increased</li>
<li>buffering at sender/receiver</li>
</ul>
</li>
</ul>
<p>Go-Back-N</p>
<ul>
<li>sender: have up to N unacked packets in pipeline</li>
<li>receiver: cumulative ack, no ack if there's a gap</li>
<li>sender has timer for oldest unacked packet (when expire, send all unacked)</li>
<li>window of N (consecutive unack'ed pkt)
<ul>
<li>cumulative ack (ack up to which n), has a timer for the oldest one</li>
<li>transmit n and higher seq packets in window</li>
</ul>
</li>
<li>receiver: ACK-only: always send ACK for correctly-received pkt with highest in-order seq #
<ul>
<li>may have duplicate ACKs, keep track of next seq num</li>
<li>out-of-order: discard, re-ACK pkt with highest in-order seq #</li>
</ul>
</li>
<li>waiting for timeout usually when things fail, as the timer is only kept for the last in-order one</li>
</ul>
<p>Selective Repeat</p>
<ul>
<li>have up to N unack'ed pkt, individual ack for each packet
<ul>
<li>have timer for each one, transmit only that one on expire</li>
</ul>
</li>
<li>needs to buffer pkts, for eventual in-order delivery</li>
<li>individual timer, resend only when un-acked</li>
<li>window: N consecutive seq #, limits the amount sent and unACKed pkts</li>
</ul>
<p>dilemma:</p>
<ul>
<li>when seq number and window are the same size, then possible to have duplicate data accepted as the new one.</li>
</ul>
<h3 id="connection-oriented-transport-tcp">Connection Oriented Transport: TCP</h3>
<ul>
<li>point to point (one sender, receiver)</li>
<li>reliable, in-order byte stream</li>
<li>pipelined</li>
<li>full duplex data - bi-directional data flow</li>
<li>connection oriented
<ul>
<li>handshaking, checking state before sending</li>
</ul>
</li>
<li>flow controlled: sender does not overwhelm receiver</li>
</ul>
<p>Q: how to set TCP timeout value?</p>
<ul>
<li>longer than RTT (but it varies)</li>
<li>too short: timeout early, unnecessary re-transmission</li>
<li>too long: slow reaction to segment loss</li>
</ul>
<p>Q: how to estimate RTT?</p>
<ul>
<li><code>SampleRTT</code>: measured time from segment transmission until ACK received
<ul>
<li>will vary, want to estimate RTT smoother -&gt; average several recent measurements, not just current RTT</li>
</ul>
</li>
</ul>
<p>TCP round trip time, timeout</p>
<ul>
<li>
<p>EstimateRTT = (1 - a)<em>EstimateRTT + a</em>SampleRTT</p>
<ul>
<li>exponentially weighted moving average</li>
<li>influence from past becomes less and less relevant</li>
<li>usually a = 0.125</li>
</ul>
</li>
<li>
<p>we need a safety margin for smoothing</p>
<ul>
<li>large variation in ERTT -&gt; larger safety margin</li>
<li>estimate SampleRTT deviation from EstimatedRTT</li>
<li>DevRTT = (1 - b) x DevRTT + b x |SampleRTT - EstimatedRTT| (b usually being 0.25)</li>
<li>TimeoutInterval = EstimatedRTT + 4 * DevRTT</li>
</ul>
</li>
<li>
<p>obviously still not perfect</p>
</li>
</ul>
<h3 id="reliable-data-transfer">Reliable data transfer</h3>
<ul>
<li>TCP creates <code>rdt</code> service on top of IP's unreliable server
<ul>
<li>pipelined segments</li>
<li>cumulative acks</li>
<li>single retransmissions timer</li>
</ul>
</li>
<li>retransmissions triggered by timeout or duplicate ack
<ul>
<li>duplicate ack is earlier than timeout and easily indicating something went wrong</li>
</ul>
</li>
</ul>
<p>Sender events</p>
<ul>
<li>data received from app:
<ul>
<li>create segment with #, start timer (oldest unacked segment)</li>
<li>expiration interval established
<ul>
<li>on timeout: retransmit segment that caused timeout, restart timer</li>
</ul>
</li>
<li>ack received
<ul>
<li>if ack is for previously unacked segments: update what is known to be acked, start timer for unacked segments.</li>
</ul>
</li>
<li>duplicate acks for when the packets arrived out of order, the duplicate ack will ask for the next one in order.</li>
</ul>
</li>
<li>detect lose segment via duplicate ACK -&gt; sender often send many segments back to back
<ul>
<li>if lost, there will likely be many duplicates</li>
</ul>
</li>
<li>TCP fast retransmit
<ul>
<li>if sender receives 3 ACKs for same data -&gt; resent unacked segment with smallest sequence, don't wait for timeout</li>
</ul>
</li>
<li>TCP rarely go to timeout (performance will be too poor if it does often)
<ul>
<li>timeout basically means nothing is received! way worse</li>
</ul>
</li>
</ul>

    </body>
    </html>